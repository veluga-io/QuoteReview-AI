<!--
동기화 영향 보고서:
- 버전 변경: [템플릿] → 1.0.0
- 수정된 원칙: 템플릿에서 모든 원칙 새로 정의됨
- 추가된 섹션: 핵심 원칙 (5개), 기술 스택 제약, 절대 제품 규칙, 보안 및 데이터 보호, 신뢰성 및 운영, 품질 기준, 아키텍처 가이드라인, MCP 사용 정책, 거버넌스
- 제거된 섹션: 없음 (첫 비준)
- 템플릿 업데이트 필요: ⚠ plan-template.md, spec-template.md, tasks-template.md 검토 대기 중
- 후속 TODO: 없음
-->

# 클라이언트 견적서 검수 시스템 헌장

## 핵심 원칙

### I. 리스크 우선 정확성 (Risk-First Correctness)

금액이나 계약 조건에 영향을 미치는 모든 사항에 대해, 시스템은 반드시 명시적인 규칙, 스키마, 계산을 통한 결정론적 검증을 사용해야 합니다. AI 출력은 절대 총액, 조건, 또는 금융 데이터의 진실 원천으로 취급되지 않으며, AI는 변경 사항을 제안하고 설명만 제공할 수 있습니다.

**AI 사용 허용 범위 (하이브리드 접근)**:
- ✅ **허용**: 이상 패턴 감지, 맥락 이해, 문구 검토, 추가 인사이트 제공
- ✅ **허용**: 비정형 데이터 해석 (예: 특이 조항, 비표준 항목 설명)
- ❌ **금지**: 수학적 계산의 유일한 검증 수단으로 사용
- ❌ **금지**: 필수 항목 존재 여부의 유일한 확인 수단으로 사용
- ⚠️ **필수**: AI 제안은 반드시 결정론적 검증과 함께 사용되어야 함

**검증 계층 구조**:
1. **Layer 1 (결정론적)**: 수학적 계산, 필수 항목, 정책 규칙 - 코드로 수행
2. **Layer 2 (AI 보조)**: 맥락 이상 감지, 문구 검토, 패턴 분석 - AI가 제안
3. **Layer 3 (인간 최종 승인)**: 모든 발견 사항 검토 및 최종 결정

**근거**: 견적 오류는 재정적 손실, 법적 책임, 고객 신뢰 훼손을 초래할 수 있습니다. 수학적 정확성은 확률론적 모델에 위임될 수 없지만, AI는 인간 검토자가 놓칠 수 있는 맥락적 문제를 발견하는 보조 도구로 활용할 수 있습니다.

### II. 기본 보안 및 기밀성 (Security & Confidentiality by Default)

견적 데이터는 기밀 비즈니스 정보입니다. 시스템은 반드시 접근을 최소화하고, 노출을 최소화하며, 민감한 데이터에 대한 모든 접근을 기록해야 합니다. 비밀 정보와 고객 데이터는 절대 도구, 로그, 프롬프트 또는 기능 작동에 엄격히 필요한 범위를 넘어선 어떤 위치로도 유출되어서는 안 됩니다.

**근거**: 견적 세부 정보는 가격 전략, 마진, 고객 관계, 경쟁 포지셔닝을 노출합니다. 무단 접근이나 유출은 비즈니스 및 법적 리스크를 발생시킵니다.

### III. 감사 가능성 및 추적성 (Auditability & Traceability) (절대 원칙)

견적에 대한 모든 변경 사항과 모든 승인 또는 거부는 반드시 기록되어야 합니다: 누가 변경했는지, 언제 발생했는지, 무엇이 수정되었는지. 시스템은 반드시 "고객에게 무엇이 전송되었는지"에 대한 불변 감사 기록을 제공해야 합니다.

**필수 감사 이벤트**:
- 견적 생성, 수정, 삭제
- 승인 부여, 승인 거부, 승인 철회
- PDF/이메일 내보내기
- 가격 규칙, 세금 계산, 할인 로직, 법적 면책 조항 변경

**근거**: 감사 기록 없이는 분쟁을 해결할 수 없고, 컴플라이언스를 입증할 수 없으며, 책임성이 불가능합니다. 이는 재무 및 법적 방어력을 위해 필수적입니다.

### IV. 사람 검수 기반 발송 (Human-in-the-Loop Shipping) (절대 원칙)

견적은 명시적인 검토자 승인 없이 "발송 준비 완료"로 표시되거나 고객에게 전송될 수 없습니다. 가격 규칙, 세금 계산, 할인 로직 또는 법적 면책 조항에 영향을 미치는 고위험 변경의 경우, 2인 검토가 필수입니다.

**승인 워크플로 규칙**:
- 초안 → 검토 요청됨 → 승인됨 → 발송 준비 완료
- 검토 요청됨에서 승인됨으로 자동 전환 금지
- 승인자 역할은 견적 작성자 역할과 구분되어야 함
- 고위험 변경은 2명의 구분된 승인자 필요

**근거**: 인간 감독 없는 자동 견적 생성은 허용 불가능한 재무 및 법적 리스크를 발생시킵니다. 인간 체크포인트는 오류에 대한 마지막 방어선입니다.

### V. 단순하고 일관된 UX (Simple, Consistent UX)

애플리케이션 전체에서 Material-UI (MUI) 패턴을 일관되게 사용하세요. MUI가 요구 사항을 충족할 수 없는 경우가 아니면 커스텀 UI 컴포넌트를 피하세요. 접근성 (WCAG 2.1 AA)과 명확한 오류 메시지는 모든 사용자 대면 기능에 필수입니다.

**UI 요구 사항**:
- MUI 컴포넌트와 테마 시스템 사용
- MUI 주변 커스텀 스타일링에만 styled-components 사용
- 함수형 React 컴포넌트와 hooks 사용
- 모든 컴포넌트 props에 TypeScript strict 모드
- 명확하고 실행 가능한 오류 메시지 (절대 "오류가 발생했습니다" 금지)

**근거**: 일관성은 인지 부하를 줄이고, 개발 속도를 높이며, 유지보수성을 보장합니다. 접근성은 법적 및 윤리적 요구 사항입니다.

## 기술 스택 제약

**프론트엔드**:
- React (최신 안정 버전) with TypeScript
- Hooks를 사용한 함수형 컴포넌트 (클래스 컴포넌트 금지)
- 컴포넌트 라이브러리로 Material-UI (MUI)
- MUI 주변 테마 및 커스텀 스타일링에 styled-components

**백엔드**:
- Serverless 아키텍처만 사용 (장기 실행 서버 금지)
- Supabase 네이티브 기능: Postgres, Auth, Storage, Edge Functions
- 권한 상승이 필요한 백엔드 로직에 Supabase Serverless Functions 사용

**데이터 플랫폼**:
- 모든 영속 데이터에 Supabase Postgres 사용
- 모든 테이블에 Row Level Security (RLS) 강제 적용
- 모든 스키마 변경에 데이터베이스 마이그레이션 사용
- 프론트엔드에서 직접 SQL 금지; RLS와 함께 Supabase 클라이언트 사용

**근거**: Serverless는 소규모 스타트업의 운영 오버헤드를 최소화합니다. Supabase는 강력한 보안 기본 요소(RLS)를 갖춘 통합 인증, 데이터베이스 및 스토리지를 제공합니다. React + TypeScript + MUI는 빠르고 타입 안전한 UI 개발을 제공합니다.

## 절대 제품 규칙

1. **발송은 워크플로 상태임**: "발송"은 승인으로 게이팅된 워크플로 상태이며, 아웃바운드 통신을 직접 트리거하는 버튼이 아닙니다. "발송" 작업은 견적을 "발송 준비 완료" 상태로 이동시키며, 별도의 시스템 또는 수동 프로세스가 실제 전달을 처리합니다.

2. **클라이언트 미리보기는 버전 관리됨**: 렌더링된 "클라이언트 PDF/미리보기"는 반드시 검증된 데이터에서 생성되어야 하며 반드시 버전 관리되어야 합니다. 모든 내보내기는 타임스탬프와 해시가 있는 새로운 불변 버전을 생성합니다.

3. **총액은 재현 가능함**: 모든 계산된 총액(소계, 세금, 할인, 총합계)은 반드시 저장된 항목 목록과 결정론적 계산 함수에서 재현 가능해야 합니다. 계산은 반드시 외부 종속성이 없는 순수 함수여야 합니다.

**근거**: 이 규칙들은 가장 일반적인 견적 오류(조기 발송, 오래된 미리보기, 재현 불가능한 총액)를 방지하고 시스템이 항상 "고객이 본 것"을 증명할 수 있도록 보장합니다.

## 보안 및 데이터 보호

### 인증 및 권한 부여

- **AuthN/AuthZ 제공자**: Supabase Auth
- **역할 기반 접근 제어 (RBAC)**: 역할 구현 (예: Admin, Sales, Reviewer, Auditor)
- **권한 부여 강제**: 모든 테이블에 Supabase Row Level Security (RLS) 사용. 절대 프론트엔드 권한 부여 체크에만 의존하지 마세요.
- **프론트엔드 체크**: UI 편의성(버튼 숨기기)에만 사용, 절대 접근 제어에 사용 금지

### 비밀 관리

- **서비스 역할 키 배포 금지**: Supabase 서비스 역할 키는 절대 클라이언트에 배포하거나 버전 관리에 커밋해서는 안 됩니다
- **Serverless 함수**: 권한 상승이 필요한 함수는 반드시 서버 측에서만 실행되어야 합니다 (Supabase Edge Functions 또는 Serverless Functions)
- **환경 변수**: 모든 API 키, 비밀, 연결 문자열에 환경별 구성 사용

### 환경

- **분리**: 개발, 스테이징, 프로덕션에 별도의 Supabase 프로젝트 사용
- **MCP 제한**: Supabase MCP 사용 시 프로덕션 데이터에 연결하지 마세요. MCP는 개발/테스트 전용입니다.
- **개발에서 프로덕션 접근 금지**: 개발 머신은 절대 프로덕션 데이터베이스 또는 API에 직접 접근해서는 안 됩니다

### 데이터 처리

- **PII 최소화**: 필요한 개인 식별 정보(PII)만 저장; 가능한 경우 수정
- **로깅 제한**: 로그는 감사에 명시적으로 필요한 경우가 아니면 견적 항목 세부 정보나 고객 PII를 포함해서는 안 됩니다 (그리고 그 경우 접근 제어되어야 함)
- **데이터 보존**: 견적, 감사 로그 및 내보내기에 대한 보존 정책 정의 및 시행

**근거**: 심층 방어 보안은 자격 증명 유출, 무단 접근 및 데이터 침해를 방지합니다. RLS는 애플리케이션 버그와 관계없이 데이터베이스 수준 강제를 보장합니다.

## 신뢰성 및 운영

### Serverless 함수 요구 사항

- **멱등성**: 모든 serverless 함수는 반드시 멱등적이고 재시도에 안전해야 합니다
- **오류 처리**: 함수는 반드시 오류 코드와 메시지가 있는 구조화된 오류를 반환해야 합니다
- **타임아웃**: 적절한 타임아웃 설정; 사용자 대면 작업의 경우 함수는 10초 이내에 완료되어야 합니다

### 상태 관리

- **데이터베이스 우선 상태 변경**: 모든 상태 변경은 반드시 트랜잭션이고 데이터베이스 우선이어야 합니다
- **부분 쓰기 방지**: 데이터베이스 트랜잭션을 사용하여 "반쯤 쓴" 견적 상태 방지
- **낙관적 잠금**: 버전 필드 또는 타임스탬프를 사용하여 동시 수정 감지

### 관찰 가능성

- **구조화된 로깅**: 중요한 흐름에 구조화된 로깅 추가 (검증 실패, 승인 이벤트, 내보내기 이벤트)
- **모니터링**: Serverless 함수 오류, 지연 시간 및 호출 횟수 모니터링
- **경고**: 검증 실패, 승인 워크플로 오류 및 내보내기 실패에 대한 경고

**근거**: Serverless 함수는 실패하고 재시도할 수 있습니다; 멱등성은 중복 작업을 방지합니다. 트랜잭션 상태 변경은 데이터 손상을 방지합니다. 관찰 가능성은 디버깅 및 인시던트 대응을 가능하게 합니다.

## 품질 기준

### 타입 안전성

- **TypeScript strict 모드**: 전체 코드베이스에 활성화
- **런타임 검증**: 런타임 스키마 검증(예: Zod)으로 모든 외부 입력(API 응답, 사용자 입력, 파일 업로드) 검증
- **`any` 타입 금지**: `any` 타입 피하기; 필요시 `unknown` 및 타입 가드 사용

### 테스트 요구 사항

**단위 테스트**:
- 모든 검증 로직은 반드시 단위 테스트가 있어야 합니다
- 모든 계산 함수(총액, 세금, 할인)는 반드시 엣지 케이스가 있는 단위 테스트가 있어야 합니다
- 목표: 도메인 로직에 대해 >80% 커버리지

**통합 테스트**:
- 승인 워크플로는 반드시 통합 테스트가 있어야 합니다 (초안 → 검토 → 승인 → 준비)
- 데이터베이스 RLS 정책은 반드시 무단 접근이 차단됨을 확인하는 통합 테스트가 있어야 합니다
- API 엔드포인트는 반드시 성공 경로와 오류 경우에 대한 통합 테스트가 있어야 합니다

**End-to-End 테스트**:
- 중요한 사용자 흐름은 반드시 E2E 테스트가 있어야 합니다: 견적 편집 → 검증 → 승인 → 내보내기
- 스테이징 환경에 대해 실제 브라우저(Playwright 또는 Cypress)로 테스트

### 코드 리뷰

- **직접 커밋 금지**: `main` 브랜치에 직접 커밋 금지; 모든 변경은 Pull Request를 통해
- **PR 리뷰 필수**: 모든 PR에 최소 1명의 검토자 승인 필요
- **고위험 PR 리뷰**: 가격, 세금, 할인 또는 면책 조항 규칙을 건드리는 변경은 2명의 검토자가 필요하며 반드시 테스트를 포함해야 합니다
- **리뷰 체크리스트**: 보안, 테스트 및 감사 기록 체크리스트가 있는 PR 템플릿 사용

**근거**: 타입 안전성은 런타임 오류를 방지합니다. 테스트는 회귀를 방지합니다. 코드 리뷰는 버그를 잡고 지식을 공유합니다. 고위험 변경은 추가 정밀 조사가 필요합니다.

## 아키텍처 가이드라인

### 관심사 분리

**명확한 분리 필수**:
- UI 컴포넌트 (React 컴포넌트, MUI 스타일링)
- 도메인 로직 (검증자, 계산기, 비즈니스 규칙)
- 데이터 접근 (Supabase 쿼리, RLS 강제 작업)

**도메인 로직 요구 사항**:
- 도메인 로직을 순수하고 결정론적으로 유지 (특히 금액 계산)
- 검증자 또는 계산기에 부작용 없음 (API 호출 없음, 데이터베이스 쓰기 없음)
- 데이터베이스 또는 네트워크 없이 독립적으로 테스트 가능

### 데이터베이스 설계

- **데이터베이스 제약 사용**: 데이터베이스 수준에서 불변성 강제 (예: 음수가 아닌 수량, 허용된 상태 열거형 값)
- **모든 테이블에 RLS**: 모든 테이블은 반드시 Row Level Security 정책이 있어야 합니다
- **마이그레이션**: 모든 스키마 변경은 마이그레이션을 통해 (프로덕션에서 수동 SQL 절대 금지)
- **감사 테이블**: 추가 전용 감사 기록에 별도 감사 테이블 사용

### 함수 순수성

**중요 로직에 순수 함수**:
- 가격 계산
- 세금 계산
- 할인 계산
- 총액 계산
- 검증 규칙

**근거**: 순수 함수는 결정론적이고, 테스트 가능하며, 캐시 가능합니다. 데이터베이스 제약은 심층 방어를 제공합니다. 명확한 분리는 독립적인 테스트와 리팩토링을 가능하게 합니다.

## MCP 사용 정책

### Supabase MCP

**허용된 사용**:
- 스키마 검사 및 문서화
- 데이터베이스 마이그레이션 작성
- 개발/테스트 환경에 대한 안전한 쿼리 생성

**금지된 사용**:
- MCP 서버를 프로덕션 데이터에 연결
- MCP 서버에 프로덕션 자격 증명 노출
- MCP를 사용하여 프로덕션 스키마 또는 데이터 수정

**근거**: MCP 서버는 데이터를 기록하고 노출할 수 있습니다. 프로덕션 데이터는 자격 증명 유출 및 데이터 노출을 방지하기 위해 절대 MCP를 통해 접근할 수 없어야 합니다.

### Chrome DevTools MCP

**허용된 사용**:
- UI 성능 문제 디버깅
- 브라우저 동작 및 네트워크 요청 검사
- 렌더링 및 레이아웃 문제 분석

**보안 고려 사항**:
- 연결된 브라우저 콘텐츠를 민감한 것으로 취급
- MCP 디버깅 세션 중 브라우저에서 개인 고객 데이터를 노출하지 마세요
- MCP 서버는 브라우저/DevTools 콘텐츠에 접근할 수 있습니다; 디버깅 중 브라우저 스토리지에 비밀이 없는지 확인

**근거**: DevTools MCP는 UI 디버깅에 유용하지만 브라우저 상태에 접근할 수 있습니다. 디버깅 세션 중 민감한 데이터 노출을 피하세요.

## 거버넌스

### 완료의 정의

기능은 다음이 모두 충족될 때 "완료"로 간주됩니다:

**보안 및 권한 부여**:
- 모든 테이블에 대해 Row Level Security (RLS) 정책이 구현되고 테스트됨
- 역할 기반 접근 제어 (RBAC) 강제됨
- 서비스 역할 키가 클라이언트에 배포되지 않음

**감사 기록**:
- 모든 상태 변경에 대한 감사 기록 구현됨
- 승인, 거부 및 내보내기에 대한 감사 이벤트 기록됨
- 감사 기록 불변 (추가 전용)

**검증 및 테스트**:
- 테스트 통과 (적절한 단위, 통합, E2E)
- 총액, 조건 또는 금융 계산에 대한 알려진 중요한 검증 격차 없음
- 고위험 변경(가격, 세금, 할인, 면책 조항)에 2인 검토 및 테스트 있음

**UI 및 접근성**:
- MUI 패턴과 일관된 UI
- 접근 가능 (WCAG 2.1 AA)
- 명확한 오류 메시지

### 변경 관리

**헌장 수정**:
- 이 헌장에 대한 변경은 팀 합의가 필요합니다 (모든 팀 구성원이 승인해야 함)
- 모든 수정은 반드시 버전 번호, 날짜 및 변경 사항 요약과 함께 기록되어야 합니다
- 버전 증가는 시맨틱 버저닝을 따릅니다:
  - MAJOR: 이전 버전과 호환되지 않는 거버넌스 또는 원칙 제거/재정의
  - MINOR: 새로운 원칙 또는 실질적으로 확장된 지침
  - PATCH: 명확화, 문구 수정, 오타 수정

**템플릿 동기화**:
- 헌장이 변경되면 종속 템플릿(plan-template.md, spec-template.md, tasks-template.md) 업데이트
- 런타임 지침 문서(README.md, quickstart, 에이전트별 문서) 업데이트

### 에스컬레이션 및 충돌 해결

**요구 사항이 핵심 원칙과 충돌할 때**:
- 충돌 예시: "빠른 출시" (비즈니스 압력) vs "리스크 우선 정확성" (원칙 I)
- **해결**: 헌장을 우선합니다. 계획과 사양에서 트레이드오프를 명시적으로 표면화하세요.
- 비즈니스 필요가 중요한 경우 팀에 에스컬레이트하여 논의
- 비즈니스 필요가 원칙을 무효화하는 경우, 먼저 헌장을 수정한 다음(팀 합의 하에) 진행

**예외 요청**:
- 기능이 원칙에 대한 예외를 필요로 하는 경우, 사양에 예외를 다음과 함께 문서화:
  - 영향을 받는 원칙
  - 예외가 필요한 이유
  - 보상 통제 또는 완화 조치
  - 팀 승인 필요

**근거**: 헌장은 기술 부채 또는 보안 리스크를 발생시키는 임시 결정을 방지합니다. 충돌은 팀 합의와 함께 투명하게 해결되어야 합니다.

---

**버전**: 1.0.0 | **비준**: 2026-01-18 | **최종 수정**: 2026-01-18
